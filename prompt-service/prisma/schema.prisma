generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Note: SQLite doesn't support native enums. The following types are used as strings:
// - VariantType: "withThinking" | "withoutThinking"
// - ThinkingType: "enabled" | "disabled"
// TypeScript validation is enforced at the application layer via Zod schemas.
// If migrating to PostgreSQL, consider converting these to native Prisma enums.

/// Main prompt definition - stores the base prompt configuration
model Prompt {
  id          String   @id @default(uuid())
  key         String   @unique
  name        String
  description String?
  content     String
  model       String
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  variants PromptVariant[]
  abTests  ABTest[]
  versions PromptVersion[]

  @@index([key])
  @@index([isActive])
}

/// Thinking mode variants for prompts (withThinking/withoutThinking configurations)
model PromptVariant {
  id           String   @id @default(uuid())
  promptId     String
  variantType  String   // "withThinking" | "withoutThinking"
  temperature  Float
  maxTokens    Int
  thinkingType String   // "enabled" | "disabled"
  budgetTokens Int?
  isDefault    Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  prompt Prompt @relation(fields: [promptId], references: [id], onDelete: Cascade)

  @@unique([promptId, variantType])
  @@index([promptId])
}

/// Version history for prompts - enables rollback and audit trail
model PromptVersion {
  id         String   @id @default(uuid())
  promptId   String
  version    Int
  content    String
  model      String
  changedBy  String?
  changeNote String?
  createdAt  DateTime @default(now())

  prompt Prompt @relation(fields: [promptId], references: [id], onDelete: Cascade)

  @@unique([promptId, version])
  @@index([promptId])
  @@index([createdAt])
}

/// A/B Test configuration - manages experiments on prompts
model ABTest {
  id          String    @id @default(uuid())
  promptId    String
  name        String
  description String?
  isActive    Boolean   @default(false)
  startDate   DateTime?
  endDate     DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  prompt   Prompt      @relation(fields: [promptId], references: [id], onDelete: Cascade)
  variants ABVariant[]

  @@index([promptId])
  @@index([isActive])
}

/// A/B Test variant - individual variant within an A/B test
model ABVariant {
  id          String   @id @default(uuid())
  abTestId    String
  name        String
  content     String
  model       String
  weight      Float    @default(0.5)
  impressions Int      @default(0)
  conversions Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  abTest  ABTest            @relation(fields: [abTestId], references: [id], onDelete: Cascade)
  configs ABVariantConfig[]

  @@index([abTestId])
}

/// A/B Variant thinking configurations
model ABVariantConfig {
  id           String @id @default(uuid())
  abVariantId  String
  variantType  String // "withThinking" | "withoutThinking"
  temperature  Float
  maxTokens    Int
  thinkingType String // "enabled" | "disabled"
  budgetTokens Int?

  abVariant ABVariant @relation(fields: [abVariantId], references: [id], onDelete: Cascade)

  @@unique([abVariantId, variantType])
  @@index([abVariantId])
}

// ============================================================================
// User Authentication Models
// ============================================================================

/// User account - stores user credentials and profile information
model User {
  id              String    @id @default(uuid())
  email           String    @unique
  password        String    // bcrypt hashed password
  emailVerified   Boolean   @default(false)
  emailVerifiedAt DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Profile fields
  name      String    // Required - collected at registration
  gender    String    // 'male' | 'female' | 'other' | 'prefer-not-to-say'
  birthYear Int       // Required - store year only for age calculation

  // Account lockout fields (progressive lockout after failed login attempts)
  failedLoginAttempts Int       @default(0)
  lockoutUntil        DateTime?
  lastFailedLoginAt   DateTime?

  refreshTokens       RefreshToken[]
  passwordResetTokens PasswordResetToken[]
  emailVerifyTokens   EmailVerifyToken[]
  assessments         Assessment[]
  analyses            Analysis[]

  @@index([email])
  @@index([createdAt])
}

/// Refresh token - enables token refresh without re-login (7 day expiry)
/// Includes device tracking and token family for rotation detection
model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())

  // Device tracking fields
  deviceInfo String?  // User agent string for session visibility
  ipAddress  String?  // IP address at token creation

  // Token family for rotation detection
  // All tokens in a refresh chain share the same familyId
  // If a revoked token is reused, the entire family is revoked (potential theft)
  familyId  String
  isRevoked Boolean  @default(false)  // Soft revoke on rotation

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
  @@index([familyId])
}

/// Password reset token - enables secure password reset flow (1 hour expiry)
model PasswordResetToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

/// Email verification token - enables email verification flow (24 hour expiry)
model EmailVerifyToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

// ============================================================================
// User Data Models - Assessment and Analysis Storage
// ============================================================================

/// User assessment - stores user's assessment responses
model Assessment {
  id        String   @id @default(uuid())
  userId    String
  responses String   // JSON-stringified AssessmentResponses
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  analyses Analysis[]

  @@index([userId])
  @@index([createdAt])
}

/// User analysis - stores AI analysis results linked to user and optionally assessment
model Analysis {
  id           String   @id @default(uuid())
  userId       String
  assessmentId String?
  result       String   // JSON-stringified AIAnalysisResult
  createdAt    DateTime @default(now())

  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  assessment Assessment? @relation(fields: [assessmentId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([assessmentId])
  @@index([createdAt])
}
