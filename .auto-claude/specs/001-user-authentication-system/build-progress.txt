=== AUTO-BUILD PROGRESS ===

Project: User Authentication System
Workspace: prompt-service (primary), app (integration)
Started: 2025-12-28

Workflow Type: feature
Rationale: Net-new JWT-based authentication system to enable persistent user accounts and cross-device assessment progress storage

Session 1 (Planner):
- Created implementation_plan.json
- Phases: 6
- Total subtasks: 19
- Created init.sh
- Created build-progress.txt

Phase Summary:
- Phase 1 (Database Schema & Dependencies): 4 subtasks, no dependencies
- Phase 2 (Auth Utilities & Services): 5 subtasks, depends on phase-1
- Phase 3 (User Service & Business Logic): 2 subtasks, depends on phase-2
- Phase 4 (JWT Authentication Middleware): 1 subtask, depends on phase-2
- Phase 5 (Authentication API Endpoints): 3 subtasks, depends on phase-3 and phase-4
- Phase 6 (Integration & End-to-End Verification): 6 subtasks, depends on phase-5

Services Involved:
- prompt-service (primary): Owns User DB, auth logic, JWT generation/validation, email service
- app (integration): Frontend will consume auth APIs (out of scope for this task)
- backend (integration): May need protected endpoints integration (out of scope for this task)

Parallelism Analysis:
- Max parallel phases: 2
- Recommended workers: 1
- Parallel groups:
  * phase-2-auth-utilities + phase-4-auth-middleware (both depend only on phase-1, different file sets)
- Speedup estimate: 1.2x faster than sequential

Implementation Approach:
1. Database-first: Set up User, RefreshToken, PasswordResetToken models
2. Utilities: Build JWT, password hashing, email, token generation utilities
3. Business logic: Create user service with registration, login, token management
4. Routes: Implement 7 auth endpoints (register, login, refresh, password-reset, password-reset/confirm, verify-email, logout)
5. Integration: Verify complete flows end-to-end

Critical Notes:
- Existing auth.routes.ts is for ADMIN sessions (API key + cookies) - keep separate
- User auth goes in user-auth.routes.ts
- Use bcryptjs ASYNC methods only (never blocking sync variants)
- JWT_ACCESS_SECRET and JWT_REFRESH_SECRET must be different
- Refresh tokens in httpOnly cookies for XSS protection
- Reuse timing-safe comparison from src/utils/crypto.ts

Verification Strategy:
- Risk level: critical
- Test types: unit, integration, e2e, security
- Security scanning: Required (secrets scan, npm audit)
- Staging deployment: Recommended

=== STARTUP COMMAND ===

To continue building this spec, run:

  cd .auto-claude && source .venv/bin/activate && python run.py --spec 001 --parallel 1

Note: Parallelism set to 1 due to sequential dependencies between phases.
      Only phase-2 and phase-4 can run concurrently (limited speedup).

=== END SESSION 1 ===

Next Steps:
1. Coder agent will pick up subtask-1-1 (install npm packages)
2. Follow phases sequentially: database → utilities → service → middleware → routes → integration
3. QA agent will verify comprehensive testing requirements after implementation

Dependencies to Install:
- jsonwebtoken
- bcryptjs
- nodemailer
- @types/jsonwebtoken
- @types/bcryptjs
- @types/nodemailer

Environment Variables Needed (add to prompt-service/.env):
- JWT_ACCESS_SECRET (generate: openssl rand -hex 32)
- JWT_REFRESH_SECRET (generate: openssl rand -hex 32, must be different)
- JWT_ACCESS_EXPIRY (recommend: 15m)
- JWT_REFRESH_EXPIRY (recommend: 7d)
- BCRYPT_SALT_ROUNDS (recommend: 10)
- SMTP_HOST (dev: smtp.ethereal.email)
- SMTP_PORT (dev: 587)
- SMTP_USER (dev: from ethereal.email/create)
- SMTP_PASSWORD (dev: from ethereal.email/create)
- SMTP_FROM_EMAIL (e.g., noreply@votive.app)
- SMTP_FROM_NAME (e.g., Votive)
- APP_URL (for email links: https://localhost:3000)
- API_URL (for internal use: http://localhost:3002)

=== SESSION UPDATE: subtask-5-2 ===
Date: 2025-12-28
Subtask: Create user auth routes file with registration, login, refresh, password reset, email verification, logout endpoints

Completed:
- Created prompt-service/src/routes/user-auth.routes.ts
- Followed ab-test.routes.ts pattern with asyncHandler wrapper
- Public routes: POST /register, POST /login, POST /refresh, POST /password-reset, POST /password-reset/confirm, GET /verify-email/:token, POST /logout
- Protected routes (require jwtAuthMiddleware): POST /resend-verification, POST /logout-all, GET /me
- Exports userAuthRoutes for main app registration

Files Created:
- prompt-service/src/routes/user-auth.routes.ts (85 lines)

Verification:
- TypeScript type-check must be run externally (npm run type-check)
- All imports verified: userAuthController and jwtAuthMiddleware exports exist

Git Commit: 9897e85

Next: subtask-5-3 - Register user auth routes in main Express app

=== SESSION UPDATE: subtask-6-1 ===
Date: 2025-12-28
Subtask: End-to-end verification of registration flow

Code Verification Complete:
- All implementation files in place and correct
- User model in prisma/schema.prisma with password, emailVerified fields
- UserService.register() properly hashes password with bcrypt, creates user in transaction
- Controller validates input with Zod, returns 201 status on success
- Routes registered at /api/user-auth/register with rate limiting (10 req/min)
- Refresh tokens stored in httpOnly cookies for XSS protection
- Email verification token generated and email sent (logged in dev mode)

Environment Setup Created:
- Created .env file from .env.example with development secrets
- JWT_ACCESS_SECRET and JWT_REFRESH_SECRET configured (different values)
- BCRYPT_SALT_ROUNDS=10, JWT_ACCESS_EXPIRY=15m, JWT_REFRESH_EXPIRY=7d

Manual Verification Required:
Since npm commands are not allowed in sandbox, the following steps must be run externally:

1. Install dependencies:
   cd prompt-service && npm install

2. Generate Prisma client:
   npm run db:generate

3. Run database migrations:
   npm run db:migrate

4. Start the service:
   npm run dev

5. Test registration endpoint:
   curl -X POST http://localhost:3002/api/user-auth/register \
     -H "Content-Type: application/json" \
     -d '{"email": "test@example.com", "password": "password123"}'
   Expected: 201 Created with { user, accessToken }

6. Verify in database:
   npx prisma studio
   Check User table has entry with bcrypt-hashed password ($2b$10$...)

Next: subtask-6-2 - End-to-end verification of login flow

=== SESSION UPDATE: subtask-6-2 ===
Date: 2025-12-28
Subtask: End-to-end verification of login flow

Code Verification Complete:
- All implementation files in place and correct
- Login route: POST /api/user-auth/login (user-auth.routes.ts:36)
- Controller: Validates with loginSchema, calls userService.login(), returns 200 with user + accessToken
- Service: Timing-safe password comparison to prevent enumeration, generic error message "Invalid email or password"
- Refresh tokens stored in database with 7-day expiry
- Access tokens generated with 15-minute expiry
- httpOnly cookie set for refresh token with sameSite: strict, secure in production
- Rate limiting: 10 requests/minute per IP (userAuthRateLimiter in routes/index.ts)

Security Features Verified:
- Timing-safe comparison: If user doesn't exist, hashes dummy password before returning error
- Generic error message: Always returns "Invalid email or password" for security
- bcrypt async methods: Uses non-blocking bcrypt.compare()
- Separate JWT secrets: JWT_ACCESS_SECRET and JWT_REFRESH_SECRET used separately
- Token type validation: Prevents using refresh token as access token
- Token rotation: New refresh token issued on each use

Manual Verification Required:
Since npm commands are not allowed in sandbox, the following steps must be run externally:

1. Ensure service is running (from subtask-6-1):
   cd prompt-service && npm install && npm run db:generate && npm run db:migrate && npm run dev

2. First, register a test user (if not already done in subtask-6-1):
   curl -X POST http://localhost:3002/api/user-auth/register \
     -H "Content-Type: application/json" \
     -d '{"email": "test@example.com", "password": "password123"}'

3. Test login endpoint:
   curl -X POST http://localhost:3002/api/user-auth/login \
     -H "Content-Type: application/json" \
     -d '{"email": "test@example.com", "password": "password123"}'
   Expected: 200 OK with { user: { id, email, emailVerified, ... }, accessToken: "eyJ..." }
   Expected: Set-Cookie header with refreshToken (httpOnly)

4. Test invalid credentials:
   curl -X POST http://localhost:3002/api/user-auth/login \
     -H "Content-Type: application/json" \
     -d '{"email": "test@example.com", "password": "wrongpassword"}'
   Expected: 401 Unauthorized with { error: "Invalid email or password", code: "AUTHENTICATION_FAILED" }

5. Test invalid email format:
   curl -X POST http://localhost:3002/api/user-auth/login \
     -H "Content-Type: application/json" \
     -d '{"email": "notanemail", "password": "password123"}'
   Expected: 400 Bad Request with Zod validation error

6. Verify refresh token in database:
   npx prisma studio
   Check RefreshToken table has entry linked to user

Next: subtask-6-3 - End-to-end verification of token refresh flow

=== SESSION UPDATE: subtask-6-4 ===
Date: 2025-12-28
Subtask: End-to-end verification of password reset flow

Code Verification Complete:
All password reset implementation files verified:
- Route: POST /api/user-auth/password-reset (request reset)
- Route: POST /api/user-auth/password-reset/confirm (confirm with token)
- Controller: requestPasswordReset and confirmPasswordReset handlers
- Service: UserService.requestPasswordReset() and confirmPasswordReset() methods
- Email: EmailService.sendPasswordResetEmail() with HTML/plaintext templates
- Validators: passwordResetRequestSchema and passwordResetConfirmSchema (Zod)
- Database: PasswordResetToken model with token, expiresAt, usedAt fields

Security Features Verified:
- Generic success message always returned (prevents user enumeration)
- Token expires after 1 hour (PASSWORD_RESET_TOKEN_EXPIRY_MS = 60*60*1000)
- Token marked as used on successful reset (usedAt field)
- All refresh tokens invalidated on password reset (forces re-login)
- New password hashed with bcrypt async methods
- Uses timing-safe token lookup via unique constraint

Manual E2E Verification Steps:
Since npm commands are not allowed in sandbox, the following steps must be run externally:

Prerequisites:
1. Get Ethereal SMTP credentials from https://ethereal.email/create
2. Update prompt-service/.env with SMTP_USER and SMTP_PASSWORD
3. Ensure service is running: cd prompt-service && npm install && npm run db:generate && npm run db:migrate && npm run dev

Step 1: Register a test user (if not already done)
   curl -X POST http://localhost:3002/api/user-auth/register \
     -H "Content-Type: application/json" \
     -d '{"email": "test@example.com", "password": "password123"}'
   Expected: 201 Created

Step 2: Request password reset
   curl -X POST http://localhost:3002/api/user-auth/password-reset \
     -H "Content-Type: application/json" \
     -d '{"email": "test@example.com"}'
   Expected: 200 OK with { message: "If an account with that email exists, a password reset link has been sent." }

Step 3: Check Ethereal inbox for reset email
   - Go to https://ethereal.email/messages
   - Find the "Reset Your Votive Password" email
   - Extract the reset token from the URL: /reset-password?token=<TOKEN>

Step 4: Confirm password reset with token
   curl -X POST http://localhost:3002/api/user-auth/password-reset/confirm \
     -H "Content-Type: application/json" \
     -d '{"token": "<TOKEN_FROM_EMAIL>", "newPassword": "newpassword456"}'
   Expected: 200 OK with { message: "Password has been reset successfully. Please login with your new password." }

Step 5: Login with new password - should succeed
   curl -X POST http://localhost:3002/api/user-auth/login \
     -H "Content-Type: application/json" \
     -d '{"email": "test@example.com", "password": "newpassword456"}'
   Expected: 200 OK with { user, accessToken }

Step 6: Verify old password no longer works
   curl -X POST http://localhost:3002/api/user-auth/login \
     -H "Content-Type: application/json" \
     -d '{"email": "test@example.com", "password": "password123"}'
   Expected: 401 Unauthorized with { error: "Invalid email or password", code: "AUTHENTICATION_FAILED" }

Additional Verification:
- Database: Check PasswordResetToken table - token should have usedAt set
- Database: Check RefreshToken table - all tokens for user should be deleted
- Security: Try using same reset token again - should fail with "Invalid or expired password reset token"

Next: subtask-6-5 - End-to-end verification of email verification flow

=== SESSION UPDATE: subtask-6-5 ===
Date: 2025-12-28
Subtask: End-to-end verification of email verification flow

Code Verification Complete:
All email verification implementation files verified:
- Route: GET /api/user-auth/verify-email/:token (user-auth.routes.ts:54)
- Controller: verifyEmail handler with Zod validation (user-auth.controller.ts:210)
- Service: UserService.verifyEmail() with token validation and user update (user.service.ts:435)
- Email: EmailService.sendEmailVerificationEmail() with HTML/plaintext templates (email.service.ts:192)
- Validators: emailVerifyTokenParamSchema (auth.validator.ts:95)
- Database: EmailVerifyToken model with token, expiresAt, usedAt fields (schema.prisma:182)

Flow Verified:
1. Registration creates EmailVerifyToken in transaction with 24-hour expiry
2. Verification email sent with link: ${APP_URL}/verify-email?token=<token>
3. GET /api/user-auth/verify-email/:token validates token param with Zod
4. Service finds token, validates not used/expired
5. Transaction updates user.emailVerified=true, user.emailVerifiedAt=now(), token.usedAt=now()
6. Returns 200 with { message, user } (SafeUser without password)

Security Features Verified:
- Token expires after 24 hours (EMAIL_VERIFY_TOKEN_EXPIRY_MS = 24*60*60*1000)
- Token marked as used on successful verification (usedAt field)
- Token cannot be reused after verification (checks usedAt !== null)
- Uses timing-safe token lookup via unique constraint
- No user enumeration - 401 for any invalid/expired token

Error Handling Verified:
- Invalid token → 401 with { error: "Invalid or expired verification token", code: "INVALID_TOKEN" }
- Expired token → 401 with { error: "Verification token expired", code: "TOKEN_EXPIRED" }
- Missing/malformed token → 400 with Zod validation error

Manual E2E Verification Steps:
Since npm commands are not allowed in sandbox, the following steps must be run externally:

Prerequisites:
1. Get Ethereal SMTP credentials from https://ethereal.email/create
2. Update prompt-service/.env with SMTP_USER and SMTP_PASSWORD
3. Ensure service is running: cd prompt-service && npm install && npm run db:generate && npm run db:migrate && npm run dev

Step 1: Register a new test user
   curl -X POST http://localhost:3002/api/user-auth/register \
     -H "Content-Type: application/json" \
     -d '{"email": "verify-test@example.com", "password": "password123"}'
   Expected: 201 Created with { user: { emailVerified: false }, accessToken }

Step 2: Check Ethereal inbox for verification email
   - Go to https://ethereal.email/messages
   - Find the "Verify Your Votive Email Address" email
   - Click message to view content
   - Extract the verification token from the URL: /verify-email?token=<TOKEN>

Step 3: Verify email with token
   curl -X GET "http://localhost:3002/api/user-auth/verify-email/<TOKEN_FROM_EMAIL>"
   Expected: 200 OK with { message: "Email verified successfully.", user: { emailVerified: true, emailVerifiedAt: "..." } }

Step 4: Verify database state
   npx prisma studio
   - Check User table - user.emailVerified should be true, emailVerifiedAt should be set
   - Check EmailVerifyToken table - token.usedAt should be set

Step 5: Verify token cannot be reused
   curl -X GET "http://localhost:3002/api/user-auth/verify-email/<SAME_TOKEN>"
   Expected: 401 Unauthorized with { error: "Invalid or expired verification token", code: "INVALID_TOKEN" }

Step 6: Verify user can login after verification
   curl -X POST http://localhost:3002/api/user-auth/login \
     -H "Content-Type: application/json" \
     -d '{"email": "verify-test@example.com", "password": "password123"}'
   Expected: 200 OK with { user: { emailVerified: true }, accessToken }

Additional Verification (Optional):
- Test expired token: Wait 24+ hours (or modify expiresAt in database) and try to verify
- Test resend verification: POST /api/user-auth/resend-verification (requires JWT auth)
- Test already verified: Resend verification for verified user should return "Email is already verified"

Next: subtask-6-6 - Verify JWT middleware protects routes correctly
